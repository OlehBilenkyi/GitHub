// '''1. Аргументы функции
// arr — это массив объектов, который нужно отсортировать.
// key — это строка, представляющая вложенный ключ, по которому нужно сортировать, например, 'address.city'.
// Пример входных данных:

// javascript
// Копировать код
// const data = [
//   { name: 'Alice', address: { city: 'Boston' } },
//   { name: 'Bob', address: { city: 'Chicago' } },
//   { name: 'Charlie', address: { city: 'Austin' } }
// ];
// 2. Разбиение ключа на части
// javascript
// Копировать код
// const keys = key.split('.'); // Разбиваем ключ по точке
// Это важно для доступа к вложенным свойствам объектов. Например, ключ 'address.city' будет преобразован в массив ['address', 'city']. То есть, сначала нужно получить объект address, затем его поле city.

// 3. Сортировка массива
// Основная логика сортировки реализована в функции sort(), которая принимает функцию сравнения двух элементов a и b.

// javascript
// Копировать код
// return arr.sort((a, b) => {
//   let aValue = a;
//   let bValue = b;

//   // Проходим по каждому уровню вложенности
//   for (let k of keys) {
//     aValue = aValue[k];
//     bValue = bValue[k];
//   }

//   // Сравнение значений
//   if (aValue < bValue) return -1;
//   if (aValue > bValue) return 1;
//   return 0;
// });
// Теперь подробнее о каждом шаге:

// Значения aValue и bValue:
// Сначала присваиваем объекту a и объекту b из массива arr начальные значения. Например, a = { name: 'Alice', address: { city: 'Boston' } } и b = { name: 'Bob', address: { city: 'Chicago' } }.

// Проход по уровням вложенности: Далее мы итерируем по каждому ключу из массива keys. Это нужно для того, чтобы получить вложенное свойство:

// Сначала для aValue и bValue мы получаем значение по ключу 'address' (это объект { city: 'Boston' } для a и { city: 'Chicago' } для b).
// Затем, на следующем уровне, мы берем значение поля city: 'Boston' для a и 'Chicago' для b.
// Сравнение значений: После того как мы получили значения aValue и bValue (в нашем случае это строки 'Boston' и 'Chicago'), происходит их сравнение:

// Если aValue меньше, возвращаем -1 (это значит, что объект a будет раньше объекта b в отсортированном массиве).
// Если aValue больше, возвращаем 1 (объект b будет раньше).
// Если значения равны, возвращаем 0 (это значит, что их позиция в массиве не изменится относительно друг друга).
// 4. Результат сортировки
// После выполнения функции, массив объектов будет отсортирован по значению вложенного ключа 'address.city':

// javascript
// Копировать код
// [
//   { name: 'Charlie', address: { city: 'Austin' } },
//   { name: 'Alice', address: { city: 'Boston' } },
//   { name: 'Bob', address: { city: 'Chicago' } }
// ]
// Таким образом, алгоритм сортирует массив объектов по вложенным значениям, независимо от уровня вложенности ключа.

// Краткий итог работы:
// Разбиваем ключ на части, чтобы работать с вложенными свойствами.
// В функции сравнения для sort() находим нужные вложенные значения для каждого объекта.
// Сравниваем их и определяем порядок объектов в массиве.

// Полезно ли это обсуждение на данный момент?

// '''
